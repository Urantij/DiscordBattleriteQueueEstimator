к сож прекомпиляцию куери не работает.

dotnet ef dbcontext optimize --precompile-queries

тупо выдаёт ошибку, что он не может получить доступ к папке /Data
я так понимаю, он лезет в папку дата в руте файл системы, угум

а паблиш сыпит миллиардом ошибок, которые нечитаемые+необъяснены.
например, он не мог юзать nested class. ну ок. а что такое
QueryPrecompilationError { SyntaxNode = context.Users.FirstOrDefaultAsync(u => u.DiscordId == discordId), Exception = System.Diagnostics.UnreachableException: IdentifierName of type ParameterSymbol: discordId
походу он не может юзать переменную аргумент, нужно локальную создавать. лол. интересно.

да, убрал везде юзание аргумента. остались теперь ошибки, что он в сгенерированном коде не имет референса на DbUser по какой то причине, ага
он включил этот неймспейс
using DiscordBattleriteQueueEstimator.Data;
но не захотело включать
namespace DiscordBattleriteQueueEstimator.Data.Models;

абалдеть, оно скомпилировалось. за 3 минуты. )


System.NotSupportedException: 'Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer.CreateDefault[System.UInt64](System.Boolean)' is missing native code. MethodInfo.MakeGenericMethod() is not compatible with AOT compilation. Inspect and fix AOT related warnings that were generated when the app was published. For more information see https://aka.ms/nativeaot-compatibility
     at System.Reflection.Runtime.MethodInfos.RuntimeNamedMethodInfo`1.GetUncachedMethodInvoker(RuntimeTypeInfo[], MemberInfo) + 0x2a
     at System.Reflection.Runtime.MethodInfos.RuntimeNamedMethodInfo`1.MakeGenericMethod(Type[]) + 0x191
     at Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer.CreateDefault(Type type, Boolean favorStructuralComparisons) + 0x5f
     at Microsoft.EntityFrameworkCore.Internal.NonCapturingLazyInitializer.EnsureInitialized[TParam,TValue](TValue&, TParam, Func`2) + 0x1d
     at Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty.<>c.<GetValueComparer>b__47_0(RuntimeProperty property) + 0x31
     at Microsoft.EntityFrameworkCore.Internal.NonCapturingLazyInitializer.EnsureInitialized[TParam,TValue](TValue&, TParam, Func`2) + 0x1d
     at DiscordBattleriteQueueEstimator.DbUserEntityType.<>c__DisplayClass1_0.<CreateAnnotations>b__0(InternalEntityEntry source) + 0x7b
     at Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry.EnsureOriginalValues() + 0x27
     at Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntrySubscriber.SnapshotAndSubscribe(InternalEntityEntry) + 0x31
     at Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.StartTracking(InternalEntityEntry) + 0x94
     at Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry.SetEntityState(EntityState oldState, EntityState newState, Boolean acceptChanges, Boolean modifyProperties) + 0x32b
     at Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry.SetEntityState(EntityState entityState, Boolean acceptChanges, Boolean modifyProperties, Nullable`1 forceStateWhenUnknownKey, Nullable`1 fallbackState) + 0xdf
     at Microsoft.EntityFrameworkCore.ChangeTracking.Internal.EntityGraphAttacher.PaintAction(EntityEntryGraphNode`1 node) + 0x12c
     at Microsoft.EntityFrameworkCore.ChangeTracking.Internal.EntityEntryGraphIterator.TraverseGraph[TState](EntityEntryGraphNode`1 node, Func`2 handleNode) + 0x2a
     at Microsoft.EntityFrameworkCore.ChangeTracking.Internal.EntityGraphAttacher.AttachGraph(InternalEntityEntry, EntityState, EntityState, Boolean) + 0x119
     at Microsoft.EntityFrameworkCore.Internal.InternalDbSet`1.SetEntityState(InternalEntityEntry, EntityState) + 0xfa
     at Microsoft.EntityFrameworkCore.Internal.InternalDbSet`1.Add(TEntity) + 0x28
     at DiscordBattleriteQueueEstimator.Data.Database.<CreateUserAsync>d__3.MoveNext() + 0x1d8
  --- End of stack trace from previous location ---
     at DiscordBattleriteQueueEstimator.Data.Database.<CreateUserAsync>d__3.MoveNext() + 0x321
  --- End of stack trace from previous location ---
     at DiscordBattleriteQueueEstimator.Work.Worker.<LoopAsync>d__14.MoveNext() + 0x1cf
  --- End of stack trace from previous location ---
     at DiscordBattleriteQueueEstimator.Work.Worker.<<DiscorbOnUserRped>b__13_0>d.MoveNext() + 0x5b
     
всёё, я сдаюсь

новый день новые страдания
dotnet ef dbcontext optimize -o Chtoto
работает...

dotnet ef dbcontext optimize --precompile-queries --nativeaot -o Generated

Successfully generated a compiled model, it will be discovered automatically, but you can also call 'options.UseModel(MyContextModel.Instance)'. Run this command again when the model is modified.
шиш

но если добавить этот юзмодель, паблиш уже выдаёт ошибку)
DiscordBattleriteQueueEstimator/DiscordBattleriteQueueEstimator/DataGen/TimeCommand.EFInterceptors.MyContext.cs(185,10): error CS9137: The 'interceptors' experimental feature is not enabled in this namespace. Add '<InterceptorsPreviewNamespaces>$(InterceptorsPreviewNamespaces);Microsoft.EntityFrameworkCore.GeneratedInterceptors</InterceptorsPreviewNamespaces>' to your project.

ой бля как же тяжело

в итоге даже можно выключить эту генерацию при паблише, закоментив таскс зависимость. но оно всё равно делает ту же ошибку
System.NotSupportedException: 'Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer.CreateDefault[System.UInt64](System.Boolean)' is missing native code. MethodInfo.MakeGenericMethod() is not compatible with AOT compilation. Inspect and fix AOT related warnings that were generated when the app was published. For more information see https://aka.ms/nativeaot-compatibility
         at System.Reflection.Runtime.MethodInfos.RuntimeNamedMethodInfo`1.GetUncachedMethodInvoker(RuntimeTypeInfo[], MemberInfo) + 0x2a
         at System.Reflection.Runtime.MethodInfos.RuntimeNamedMethodInfo`1.MakeGenericMethod(Type[]) + 0x191
         at Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer.CreateDefault(Type type, Boolean favorStructuralComparisons) + 0x5f
         at Microsoft.EntityFrameworkCore.Internal.NonCapturingLazyInitializer.EnsureInitialized[TParam,TValue](TValue&, TParam, Func`2) + 0x1d
         at Microsoft.EntityFrameworkCore.Metadata.RuntimeProperty.<>c.<GetValueComparer>b__47_0(RuntimeProperty property) + 0x31
         at Microsoft.EntityFrameworkCore.Internal.NonCapturingLazyInitializer.EnsureInitialized[TParam,TValue](TValue&, TParam, Func`2) + 0x1d
         at DiscordBattleriteQueueEstimator.DbUserEntityType.<>c__DisplayClass1_0.<CreateAnnotations>b__0(InternalEntityEntry source) + 0x7b
         at Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry.EnsureOriginalValues() + 0x27
         at Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntrySubscriber.SnapshotAndSubscribe(InternalEntityEntry) + 0x31
         at Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.StartTracking(InternalEntityEntry) + 0x94
         at Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry.SetEntityState(EntityState oldState, EntityState newState, Boolean acceptChanges, Boolean modifyProperties) + 0x32b
         at Microsoft.EntityFrameworkCore.ChangeTracking.Internal.InternalEntityEntry.SetEntityState(EntityState entityState, Boolean acceptChanges, Boolean modifyProperties, Nullable`1 forceStateWhenUnknownKey, Nullable`1 fallbackState) + 0xdf
         at Microsoft.EntityFrameworkCore.ChangeTracking.Internal.EntityGraphAttacher.PaintAction(EntityEntryGraphNode`1 node) + 0x12c
         at Microsoft.EntityFrameworkCore.ChangeTracking.Internal.EntityEntryGraphIterator.TraverseGraph[TState](EntityEntryGraphNode`1 node, Func`2 handleNode) + 0x2a
         at Microsoft.EntityFrameworkCore.ChangeTracking.Internal.EntityGraphAttacher.AttachGraph(InternalEntityEntry, EntityState, EntityState, Boolean) + 0x119
         at Microsoft.EntityFrameworkCore.Internal.InternalDbSet`1.SetEntityState(InternalEntityEntry, EntityState) + 0xfa
         at Microsoft.EntityFrameworkCore.Internal.InternalDbSet`1.Add(TEntity) + 0x28
         at DiscordBattleriteQueueEstimator.Data.Database.<CreateUserAsync>d__3.MoveNext() + 0x1d8
      --- End of stack trace from previous location ---
         at DiscordBattleriteQueueEstimator.Data.Database.<CreateUserAsync>d__3.MoveNext() + 0x321
      --- End of stack trace from previous location ---
         at DiscordBattleriteQueueEstimator.Work.Worker.<LoopAsync>d__14.MoveNext() + 0x1cf
      --- End of stack trace from previous location ---
         at DiscordBattleriteQueueEstimator.Work.Worker.<<DiscorbOnUserRped>b__13_0>d.MoveNext() + 0x5b

и кстати в подсказке он говорит, что просто заюзайте ещё раз команду, если модели изменятся. он сыпет ошибками, если не удалить всё.

оказалось, нужно было просто зарегать свой велью компарер для юлонг.
икс дэ дэ

НО ЕГО НЕЛЬЗЯ СДЕЛАТЬ ГЛОБАЛЬНО, ДЛЯ КАЖДОГО ПОЛЯ НАСТАРАИВАТЬ НУЖНО. оогооо, вот так хуйня
https://learn.microsoft.com/en-us/ef/core/modeling/bulk-configuration#example-default-length-for-all-string-properties
если конвекции поддерживаю, мы гучи.
мы гучи.

переместил модельки в свои неймспейсы, сгенерированный код опять сфейлился добавить референс. ну ладно, я не гордый, сам добавлю

бандлер пишет
Don't forget to copy appsettings.json alongside your bundle if you need it to apply migrations.
я не пон зачем. он ниче с ним не делает

АОТ. ИТОГИ.

- пришлось писать комперер
- неймспейсы сами не включаются
- енсур криеетед или миграция не работают, нужно создавать свой бандлер
- опции практически неюзабельны
- компиляция 3 минуты
- размер исполняемого файла - 44МБ. дбг - 121МБ

условия содержания

- нужно пересобирать генерированный код, когда создаётся новое обращение к бд или вообще любое изменение кода, так как интерцепторы привязаны к номеру строки
- и так как изменение в строчках создаст ошибку для сгенерированного кода, оно не сможет забилдить проект и скомпилироваться
- так что папку Generated нужно удалить.... а потом юзинги сделать...
dotnet ef dbcontext optimize --precompile-queries --nativeaot -o Generated
- нужно создавать миграцию, когда меняется модель бд (не связано с аот, так всегда)
dotnet ef migrations add Migration_Name
- нужно компилировать бандлер, когда меняется модель бд
// предполагается, что на сервере есть дотнет. если нет, нужно добавить аргумент --self-contained. селф контейнед весит 100МБ, но селф контейнед 30МБ
dotnet ef migrations bundle -r linux-x64 --force

...

если бы неймспейсы генерировались нормально, я бы включил автогенерацию, чтобы каждое новое обращение к бд не требовало перекомпиляции.
но увырге. лучше я включу генерацию руками, и чтобы оно фейлилось в самом начале паблиша с жалобой на неймспейс.

возможно, можно самому следить за состоянием миграции и вручную делать миграции, юзая генерируемые Migration, но мне впадлу пока что
https://learn.microsoft.com/en-us/ef/core/managing-schemas/migrations/applying?tabs=dotnet-core-cli#apply-migrations-at-runtime
Carefully consider before using this approach in production. Experience has shown that the simplicity of this deployment strategy is outweighed by the issues it creates. Consider generating SQL scripts from migrations instead.
то есть... ето возможно

<Features>InterceptorsPreview</Features> оказалось ненужно

<InterceptorsNamespaces>$(InterceptorsPreviewNamespaces);Microsoft.EntityFrameworkCore.GeneratedInterceptors</InterceptorsNamespaces>
<InterceptorsPreviewNamespaces>$(InterceptorsPreviewNamespaces);Microsoft.EntityFrameworkCore.GeneratedInterceptors</InterceptorsPreviewNamespaces>
и то и то работает, я выбираю первое

<PackageReference Include="Microsoft.EntityFrameworkCore.Tasks" Version="9.0.0">
    <PrivateAssets>all</PrivateAssets>
    <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
</PackageReference>
в муте клоун